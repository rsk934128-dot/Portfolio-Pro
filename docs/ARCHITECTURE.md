# Architecture Overview

This document provides an overview of the system architecture for the AI-Powered Portfolio & Blog Platform.

## Core Components

1.  **Frontend:** A [Next.js](https://nextjs.org/) application using the App Router, hosted on [Vercel](https://vercel.com/).
2.  **UI:** Built with [React](https://react.dev/), [ShadCN UI](https://ui.shadcn.com/), and styled with [Tailwind CSS](https://tailwindcss.com/).
3.  **Backend & Database:** [Firebase](https://firebase.google.com/) provides the backend services, primarily [Cloud Firestore](https://firebase.google.com/docs/firestore) for the database.
4.  **Generative AI:** AI features are powered by the [Google AI SDK (Gemini)](https://ai.google.dev/) and integrated via [Genkit](https://firebase.google.com/docs/genkit).
5.  **Authentication:** Managed by [Firebase Authentication](https://firebase.google.com/docs/auth) for secure access to write operations.

## Data Flow Diagram

```
[Visitor] --> [Next.js Frontend on Vercel]
   |                  |
   | (Read)           | (Read/Write with Auth)
   '----------------> [Cloud Firestore]
                      |
[AI Blog Assistant] <-' (Server Action) --> [Genkit (Google AI)]
```

### Explanation

*   **Visitor Interaction:** A visitor accesses the site hosted on Vercel. All pages are server-rendered or statically generated by Next.js for fast initial loads.
*   **Data Fetching (Client-Side):** Client components use React hooks (`useDoc`, `useCollection`) to subscribe to real-time data from Cloud Firestore. This ensures the portfolio content (profile, projects, blog posts) is always up-to-date.
*   **Security:** Public data is readable by anyone, as defined in `firestore.rules`. Write operations (like submitting the contact form or, for an admin, creating a blog post) are secured. Only authenticated users can write to their own data tree.
*   **AI Feature Integration:** AI tools like the "Blog Assistant" are implemented as Next.js Server Actions.
    1.  The client-side component calls a server action with the necessary input (e.g., blog content).
    2.  The server action, running on the server, communicates with the Google AI API via Genkit.
    3.  The AI model processes the request and returns the result (e.g., SEO title, summary, tags).
    4.  The server action can then write this new data directly to Firestore (e.g., saving a new blog post).

## Client vs. Server Boundaries

*   **Client-Side (`'use client'`):**
    *   All UI components that involve user interaction (buttons, forms, carousels).
    *   All components that fetch real-time data from Firestore using the provided React hooks.
    *   The main pages (`page.tsx`, `blog/[slug]/page.tsx`) are client components to manage data fetching hooks.

*   **Server-Side (`'use server'`):**
    *   The AI flow files in `src/ai/flows/` are server-only modules.
    *   The action file `src/app/actions.ts` defines the server actions that bridge the client and the AI backend. This is a secure boundary that prevents client-side code from directly accessing the AI API keys.

## Scalability

*   **Frontend:** Vercel provides automatic scaling, a global CDN, and serverless functions to handle traffic spikes effortlessly.
*   **Backend:** Firebase Firestore is a serverless, NoSQL database designed for massive scalability, automatically handling sharding and replication.
*   **AI:** Google's AI platform is built for planet-scale applications.

This architecture is designed to be robust, secure, and highly scalable, suitable for a professional-grade personal media platform.
