/**
 * This ruleset enforces a strict user-ownership model for a personal portfolio website.
 * The core philosophy is to isolate user data, ensuring that users can only access and manage their own information.
 * All user-specific data is publicly readable to allow for a public portfolio, but writes are strictly controlled.
 *
 * Core Philosophy:
 * Data is segregated into two main categories: private user-owned data and public/semi-public application data.
 * All user-specific content (profiles, projects, skills, etc.) is stored within a private data tree, making security straightforward and performant.
 * Publicly readable data (like testimonials) and write-only data (like contact submissions) are stored in separate top-level collections.
 *
 * Data Structure:
 * All private user data is nested under `/users/{userId}`. This path-based ownership is the foundation of the security model.
 * - /users/{userId}: The user's root profile document.
 * - /users/{userId}/projects/{projectId}: The user's project portfolio.
 * - /users/{userId}/skills/{skillId}: The user's skills.
 * - /users/{userId}/certifications/{certificationId}: The user's certifications.
 * - /users/{userId}/blogPosts/{blogPostId}: The user's blog posts.
 * Top-level collections are used for shared or special-purpose data:
 * - /contactFormSubmissions: A write-only "dropbox" for contact form messages.
 * - /testimonials: A public collection for testimonials.
 *
 * Key Security Decisions:
 * - Public Reads, Private Writes: All data under `/users/{userId}` is publicly readable, but write access is restricted to the authenticated user whose UID matches `{userId}`.
 * - No User Listing: It is not possible to list all documents in the `/users` collection, protecting user privacy.
 * - Write-Only Contact Form: Anyone can submit to the `/contactFormSubmissions` collection, but no one can read, update, or delete submissions from the client, protecting the submitter's privacy.
 * - Public Testimonials: The `/testimonials` collection is publicly readable by anyone, but writes are disabled by default until a secure mechanism (like admin roles or ownership fields) is implemented.
 *
 * Denormalization for Authorization:
 * In this prototyping phase, ownership is primarily determined by the document's path (`/users/{userId}`). For the root user profile, relational integrity is enforced on creation by requiring the document's internal `id` field to match the `{userId}` from the path. This avoids costly lookups and ensures data consistency.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to improve readability and maintainability.

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing data ownership for write operations.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document for write operations.
     * CRITICAL: Used for all update and delete operations to prevent modifying non-existent data.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && exists(/databases/$(database)/documents/users/$(userId));
    }

    /**
     * @description Rules for user profile documents. A user's profile is public, but only they can edit it.
     * @path /users/{userId}
     * @allow Anyone can (get) a user profile.
     * @allow A signed-in user (auth.uid: 'user123') can (create) and (update) their own profile at `/users/user123`.
     * @deny A signed-in user (auth.uid: 'user456') cannot (update) the profile at `/users/user123`.
     * @principle Restricts write access to a user's own data tree while allowing public reads.
     */
    match /users/{userId} {
      allow get: if true;
      allow list: if false; // Deny listing all users for privacy.
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);

      /**
       * @description Rules for a user's projects. Publicly readable, owner-only writes.
       * @path /users/{userId}/projects/{projectId}
       * @allow Anyone can (get) or (list) projects.
       * @deny User 'user456' cannot (create) a project for user 'user123'.
       * @principle Enforces document ownership within a user's private subcollection.
       */
      match /projects/{projectId} {
        allow get: if true;
        allow list: if true;
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Rules for a user's skills. Publicly readable, owner-only writes.
       * @path /users/{userId}/skills/{skillId}
       * @allow Anyone can (get) or (list) skills.
       * @deny User 'user456' cannot (create) a skill for user 'user123'.
       * @principle Enforces document ownership within a user's private subcollection.
       */
      match /skills/{skillId} {
        allow get: if true;
        allow list: if true;
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Rules for a user's certifications. Publicly readable, owner-only writes.
       * @path /users/{userId}/certifications/{certificationId}
       * @allow Anyone can (get) or (list) certifications.
       * @deny User 'user456' cannot (create) a certification for user 'user123'.
       * @principle Enforces document ownership within a user's private subcollection.
       */
      match /certifications/{certificationId} {
        allow get: if true;
        allow list: if true;
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Rules for a user's blog posts. Publicly readable, owner-only writes.
       * @path /users/{userId}/blogPosts/{blogPostId}
       * @allow Anyone can (get) or (list) blog posts.
       * @deny User 'user456' cannot (create) a blog post for user 'user123'.
       * @principle Enforces document ownership within a user's private subcollection.
       */
      match /blogPosts/{blogPostId} {
        allow get: if true;
        allow list: if true;
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description Allows anyone to submit a message to the contact form. This collection acts as a secure "dropbox."
     * @path /contactFormSubmissions/{contactFormSubmissionId}
     * @allow Any user, including anonymous ones, can (create) a new submission.
     * @deny No user can (get), (list), (update), or (delete) any submission to protect privacy.
     * @principle Secures sensitive data by making it write-only from the client-side.
     */
    match /contactFormSubmissions/{contactFormSubmissionId} {
      allow get: if false;
      allow list: if false;
      allow create: if true;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to all testimonials. Writes are disabled pending a secure implementation.
     * @path /testimonials/{testimonialId}
     * @allow Any user, including unauthenticated ones, can (get) or (list) testimonials.
     * @deny No user can (create), (update), or (delete) a testimonial via the client SDK.
     * @principle Provides public read access while preventing unauthorized modification.
     */
    match /testimonials/{testimonialId} {
      allow get: if true;
      allow list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'Testimonial' entity is missing an 'ownerId' or 'authorId' field.
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }
}
